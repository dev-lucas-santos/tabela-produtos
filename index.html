<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="responsivo.css">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" 
    integrity="sha512-1ycn6IcaQQ40/MKBW2W4Rhis/DbILU74C1vSrLJxCq57o941Ym01SwNsOMqvEBFlcgUa6xLiPY/NS5R+E6ztJQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
   
    <title>Tabela de Produtos</title>
  
</head>
<body>

    <h1>Gestão de Produtos</h1>
    <span id="storageStatus" class="storage-status hidden" aria-live="polite">Dados salvos no dispositivo</span>

    <div class="form-container">
        <input type="text" id="productName" placeholder="Nome do Produto">
        <input type="number" id="productQuantity" placeholder="Quantidade" min="0">
        <input type="date" id="productDate">
        <button onclick="addProduct()">Adicionar Produto</button>

        <!-- Campo de busca e botão -->
        <input type="text" id="searchInput" placeholder="Buscar produto...">
        <button onclick="searchProducts()">Buscar</button>
    </div>

    <div class="table-wrapper">
        <table>
            <thead>
                <tr>
                    <th onclick="sortTable(0)">Nome do Produto</th>
                    <th onclick="sortTable(1)">Data de Cadastro</th>
                    <th onclick="sortTable(2)">Quantidade</th>
                    <th>Ações</th>
                </tr>
            </thead>
            <tbody id="productList">
                <!-- Linhas de produtos serão adicionadas aqui via JavaScript -->
            </tbody>
        </table>
    </div>

    <script>
        const productList = document.getElementById('productList');
        const STORAGE_KEY = 'tabela_produtos_v1';
        const QUEUE_KEY = 'tabela_produtos_queue_v1';
        const API = 'http://localhost:3000/api/products';
        let products = []; // Array para armazenar os dados dos produtos
        let sortDirection = { 0: 1, 1: 1, 2: 1 }; // 1 = asc, -1 = desc
        let queue = [];

        function saveProductsToStorage() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(products));
        }

        function saveQueueToStorage() {
            localStorage.setItem(QUEUE_KEY, JSON.stringify(queue));
            updateStorageStatus();
        }

        function loadQueueFromStorage() {
            const raw = localStorage.getItem(QUEUE_KEY);
            if (!raw) return [];
            try { return JSON.parse(raw); } catch (e) { return []; }
        }

        function loadProductsFromStorage() {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (raw) {
                try {
                    products = JSON.parse(raw);
                    // garante que tenha quantity (compatibilidade com versões antigas)
                    products = products.map(p => ({ id: p.id, name: p.name, date: p.date, quantity: (p.quantity || 1) }));
                } catch (e) {
                    products = [];
                }
            } else {
                products = [];
            }
        }

        function addProduct() {
            const nameInput = document.getElementById('productName');
            const quantityInput = document.getElementById('productQuantity');
            const dateInput = document.getElementById('productDate');
            const name = nameInput.value.trim();
            const date = dateInput.value;
            const quantity = parseInt(quantityInput.value, 10);

            if (!name || !date) {
                alert('Por favor, preencha nome e data.');
                return;
            }
            if (!Number.isInteger(quantity) || quantity <= 0) {
                alert('Quantidade deve ser um número inteiro maior que zero.');
                return;
            }

            const id = Date.now();
            const newProduct = { id, name, date, quantity };
            products.push(newProduct);
            // enfileira a operação para sincronizar com API quando possível
            queue.push({ type: 'add', product: newProduct });
            saveProductsToStorage();
            saveQueueToStorage();
            renderTable();
            nameInput.value = '';
            dateInput.value = '';
            quantityInput.value = '';
            // tenta sincronizar imediatamente
            flushQueue();
        }

        // renderTable agora aceita uma lista opcional para mostrar (padrão: todos os produtos)
        function renderTable(list = products) {
            productList.innerHTML = ''; 
            
            if (!list.length) {
                productList.innerHTML = '<tr><td colspan="4" style="text-align:center;color:#666;padding:12px;">Nenhum produto encontrado</td></tr>';
                return;
            }

            list.forEach(product => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${escapeHtml(product.name)}</td>
                    <td>${new Date(product.date + 'T00:00:00').toLocaleDateString('pt-BR')}</td>
                    <td style="text-align:center">${product.quantity}</td>
                    <td style="white-space:nowrap">
                        <button class="qty-btn" onclick="changeQuantity(${product.id}, -1)">Retirar</button>
                        <button class="qty-btn" onclick="changeQuantity(${product.id}, 1)">Adicionar</button>
                        <button class="delete-btn" onclick="deleteProduct(${product.id})">Excluir</button>
                    </td>
                `;
                productList.appendChild(row);
            });
        }

        function sortTable(columnIndex) {
            const dir = sortDirection[columnIndex] || 1;

            products.sort((a, b) => {
                if (columnIndex === 0) {
                    return dir * a.name.localeCompare(b.name);
                } else if (columnIndex === 1) {
                    const dateA = new Date(a.date);
                    const dateB = new Date(b.date);
                    return dir * (dateA - dateB);
                } else if (columnIndex === 2) {
                    return dir * (a.quantity - b.quantity);
                }
                return 0;
            });

            sortDirection[columnIndex] = -dir;
            saveProductsToStorage();
            const q = document.getElementById('searchInput').value.trim();
            if (q) searchProducts(); else renderTable();
        }

        // Busca por nome (ou por data formatada). Se campo vazio, mostra todos.
        function searchProducts() {
            const q = document.getElementById('searchInput').value.trim().toLowerCase();
            if (!q) {
                renderTable();
                return;
            }
            const filtered = products.filter(p => {
                const nameMatch = p.name.toLowerCase().includes(q);
                const dateStr = new Date(p.date + 'T00:00:00').toLocaleDateString('pt-BR').toLowerCase();
                const dateMatch = dateStr.includes(q);
                const qtyMatch = String(p.quantity).includes(q);
                return nameMatch || dateMatch || qtyMatch;
            });
            renderTable(filtered);
        }

        function changeQuantity(id, delta) {
            const idx = products.findIndex(p => p.id === id);
            if (idx === -1) return;
            products[idx].quantity = Math.max(0, products[idx].quantity + delta);
            if (products[idx].quantity === 0) {
                // remove automaticamente quando chega a zero
                products.splice(idx, 1);
                queue.push({ type: 'delete', id });
            } else {
                queue.push({ type: 'updateQuantity', id, delta });
            }
            saveProductsToStorage();
            saveQueueToStorage();
            const q = document.getElementById('searchInput').value.trim();
            if (q) searchProducts();
            else renderTable();
            flushQueue();
        }

        function deleteProduct(id) {
            if (!confirm('Deseja excluir este produto?')) return;
            const idx = products.findIndex(p => p.id === id);
            if (idx === -1) return;
            products.splice(idx, 1);
            queue.push({ type: 'delete', id });
            saveProductsToStorage();
            saveQueueToStorage();
            const q = document.getElementById('searchInput').value.trim();
            if (q) searchProducts();
            else renderTable();
            flushQueue();
        }

        // Pequena função para evitar injeção ao inserir texto no innerHTML
        function escapeHtml(text) {
            const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
            return String(text).replace(/[&<>"']/g, m => map[m]);
        }

        
        // Helper para mostrar o estado de armazenamento (local / remoto)
        function setStorageStatus(text, show) {
            const el = document.getElementById('storageStatus');
            if (!el) return;
            el.textContent = text || '';
            if (show) el.classList.remove('hidden'); else el.classList.add('hidden');
        }

        // Carrega produtos salvos ao abrir a página
        document.addEventListener('DOMContentLoaded', () => {
            loadProductsFromStorage();
            queue = loadQueueFromStorage();
            renderTable();
            // Atualiza indicador de armazenamento conforme estado da fila/API
            updateStorageStatus();
            // tenta sincronizar em background imediatamente
            flushQueue();
            // e periodicamente
            setInterval(flushQueue, 15000);
            // também reativa quando navigator fica online
            window.addEventListener('online', () => { flushQueue(); });
        });

        // Atualiza o badge de status de armazenamento
        function updateStorageStatus() {
            // se não houver fila e estiver online, consideramos sincronizado
            if (queue.length === 0 && navigator.onLine) {
                // opcional: checar API com um ping
                setStorageStatus('Sincronizado', true);
                return;
            }
            if (!navigator.onLine) {
                setStorageStatus('Offline — dados salvos localmente', true);
                return;
            }
            if (queue.length > 0) {
                setStorageStatus('Alterações pendentes (salvas localmente)', true);
                return;
            }
            setStorageStatus('', false);
        }

        // Tenta enviar operações pendentes para a API
        async function flushQueue() {
            if (!queue || !queue.length) { updateStorageStatus(); return; }
            // tenta processar em ordem
            let changed = false;
            for (let i = 0; i < queue.length; ) {
                const op = queue[i];
                try {
                    if (op.type === 'add') {
                        const res = await fetch(API, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(op.product) });
                        if (res.ok) {
                            const saved = await res.json();
                            // atualiza id local para id do servidor
                            const idx = products.findIndex(p => p.id === op.product.id);
                            if (idx !== -1) { products[idx].id = saved.id; }
                            // atualizar futuros ops que referenciam o id temporário
                            queue.forEach(qop => {
                                if (qop.id === op.product.id) qop.id = saved.id;
                                if (qop.product && qop.product.id === op.product.id) qop.product.id = saved.id;
                            });
                            queue.splice(i, 1);
                            changed = true;
                            continue; // não incrementa i para processar novo elemento na mesma posição
                        }
                    } else if (op.type === 'updateQuantity') {
                        const res = await fetch(`${API}/${op.id}/quantity`, { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ delta: op.delta }) });
                        if (res.ok) { queue.splice(i, 1); changed = true; continue; }
                    } else if (op.type === 'delete') {
                        const res = await fetch(`${API}/${op.id}`, { method: 'DELETE' });
                        if (res.ok || res.status === 404) { queue.splice(i, 1); changed = true; continue; }
                    }
                } catch (e) {
                    // problema de rede; aborta tentativa e espera próximo flush
                    break;
                }
                // se não removemos o item, avançamos para o próximo para evitar loop infinito
                i++;
            }
            if (changed) {
                saveProductsToStorage();
            }
            saveQueueToStorage();
            updateStorageStatus();
        }
    </script>

    <footer>
        <p>2025-DEV-Lucas-Silva</p>
        <a class="contato" href="https://github.com/DEV-Lucas-Silva" target="_blank" rel="noopener">Contato</a>

        <!--  ajustar hrefs para seus links/telefone  -->
        <span class="footer-icons">
            <a href="mailto:lucastumblr1997@gmail.com" title="E-mail" aria-label="E-mail" target="_blank" rel="noopener">
                <i class="fas fa-envelope"></i>
            </a>
            <a href=" https://www.linkedin.com/in/lucas-santos-silva-521aba297?utm_source=share&utm_campaign=share_via&utm_content=profile&utm_medium=ios_app" title="LinkedIn" aria-label="LinkedIn" target="_blank" rel="noopener">
                <i class="fab fa-linkedin-in"></i>
            </a>
            <a href="https://wa.me/5511998222517" title="WhatsApp" aria-label="WhatsApp" target="_blank" rel="noopener">
                <i class="fab fa-whatsapp"></i>
            </a>
        </span>

    
    </footer>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/js/all.min.js" 
    integrity="sha512-Tn2m0TIpgVyTzzvmxLNuqbSJH3JP8jm+Cy3hvHrW7ndTDcJ1w5mBiksqDBb8GpE2ksktFvDB/ykZ0mDpsZj20w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>


</body>
</html>
